
"Sphere should inherit from Hittable abstract class and define it's hit method"

#include "Hittable.h"
#include "Vec3.h"

class Sphere : public Hittable {
public:
    Sphere() {}
    Sphere(Vec3 center, double radius) : center(center), radius(radius) {}

    virtual bool hit(const Ray& r, double t_min, double t_max, HitRecord& rec) const override {
        Vec3 oc = r.origin() - center;
        double a = r.direction().length_squared();
        double half_b = dot(oc, r.direction());
        double c = oc.length_squared() - radius * radius;
        double discriminant = half_b * half_b - a * c;

        if (discriminant > 0) {
            double root = sqrt(discriminant);
            double temp = (-half_b - root) / a;
            if (temp < t_max && temp > t_min) {
                rec.t = temp;
                rec.p = r.at(rec.t);
                Vec3 outward_normal = (rec.p - center) / radius;
                rec.set_face_normal(r, outward_normal);
                return true;
            }
            temp = (-half_b + root) / a;
            if (temp < t_max && temp > t_min) {
                rec.t = temp;
                rec.p = r.at(rec.t);
                Vec3 outward_normal = (rec.p - center) / radius;
                rec.set_face_normal(r, outward_normal);
                return true;
            }
        }
        return false;
    }

public:
    Vec3 center;
    double radius;
};

Rework needed as this is not consistent with the codebase








// Write a function to set normal face
inline void set_face_normal(Ray r, GeoVec outward_normal) {
    front_face = r.direction.dot(outward_normal) < 0;
    normal = front_face ? outward_normal : -outward_normal;
}

// Functiont to negate a vector
inline GeoVec operator-(const GeoVec& v)
{
	return GeoVec(-v.x, -v.y, -v.z);
}


write a class that defines a real-valued time interval

class Interval {
public:
  Interval(double start, double end) : start_(start), end_(end) {}

  double start() const { return start_; }
  double end() const { return end_; }
  double length() const { return end_ - start_; }

private:
  double start_;
  double end_;
};


write makefile to compile all cpp/h files and create an obj dir to place the .o files into

# Define compiler and flags
CXX = g++
CXXFLAGS = -Wall -Wextra -pedantic -std=c++11

# Define source and object file directories
SRCDIR = .
OBJDIR = obj

# Define source and object files
SRCS = $(wildcard $(SRCDIR)/*.cpp)
OBJS = $(patsubst $(SRCDIR)/%.cpp,$(OBJDIR)/%.o,$(SRCS))

# Define target executable
TARGET = myprogram

# Default target
all: $(TARGET)

# Rule to create object files
$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Rule to link object files into executable
$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) $^ -o $@

# Clean rule
clean:
	rm -f $(OBJDIR)/*.o $(TARGET)



define a class Cylinder that represents a closed-top cylinder and inherits from Hittable. This class should take GeoVec parameters for centre amd axis as well as double values for the radius and height. Then implement the hit method to test for closed-top and body ray intersection with the cylinder




write a Triangle class that stores 3 GeoVec vertices and define the hit function for ray intersection


#ifndef TRIANGLE_H
#define TRIANGLE_H

#include "Hittable.h"
#include "GeoVec.h"

class Triangle : public Hittable {
public:
    Triangle() {}
    Triangle(const GeoVec& v0, const GeoVec& v1, const GeoVec& v2)
        : m_v0(v0), m_v1(v1), m_v2(v2) {}

    bool Triangle::hit(Ray& r, double t_min, double t_max, HitRecord& rec) const {
        GeoVec e1 = m_v1 - m_v0;
        GeoVec e2 = m_v2 - m_v0;
        GeoVec pvec = cross(r.direction, e2);
        double det = dot(e1, pvec);

        if (det < 1e-8 && det > -1e-8) {
            return false;
        }

        double inv_det = 1.0 / det;
        GeoVec tvec = r.origin - m_v0;
        double u = dot(tvec, pvec) * inv_det;

        if (u < 0.0 || u > 1.0) {
            return false;
        }

        GeoVec qvec = cross(tvec, e1);
        double v = dot(r.direction, qvec) * inv_det;

        if (v < 0.0 || u + v > 1.0) {
            return false;
        }

        double t = dot(e2, qvec) * inv_det;

        if (t < t_min || t > t_max) {
            return false;
        }

        rec.t = t;
        rec.point = r.at(t);
        GeoVec outward_normal = normalize(cross(e1, e2));
        rec.set_face_normal(r, outward_normal);

        return true;
    }

private:
    GeoVec m_v0, m_v1, m_v2;
};
#endif // TRIANGLE_H

// Write a function that generates a random vector
inline GeoVec random()
{
    return GeoVec(drand48(), drand48(), drand48());
}   


// write a function that generates a random vector in the same hemisphere as normal
inline GeoVec random_in_hemisphere(const GeoVec& normal)
{
    GeoVec in_unit_sphere = random_in_unit_sphere();
    if(dot(in_unit_sphere, normal) > 0.0)
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

define Light class that has a position and intesity both stored as GeoVec with constructor

#include "GeoVec.h"

class Light {
public:
    GeoVec position;
    GeoVec intensity;

    Light(GeoVec pos, GeoVec inten) : position(pos), intensity(inten) {}
};

write a class to represent Binary rendering on ray intersection that inherits from RenderMode.h

#include "RenderMode.h"

class BinaryRender : public RenderMode {
public:
  BinaryRender() : RenderMode("Binary") {}

  virtual Color shade(const Ray& ray, const Scene& scene) const override {
    // Find the closest intersection point
    HitRecord hitRecord;
    if (!scene.hit(ray, hitRecord)) {
      return Color(0, 0, 0); // Return black if no intersection
    }

    // Return white if there is an intersection
    return Color(1, 1, 1);
  }
};
